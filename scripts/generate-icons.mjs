#!/usr/bin/env node

/**
 * Remix Icon Code Generator
 *
 * Reads all Remix Icon SVGs from node_modules/remixicon/icons/{Category}/*.svg,
 * extracts path data, and generates:
 *   - Per-icon .tsx components (packages/icons/generated/Ri{PascalCase}.tsx)
 *   - Barrel export (packages/icons/index.ts)
 *   - TypeScript types (packages/icons/types.ts)
 *   - Machine-readable manifest (packages/icons/manifest.json)
 *
 * Uses only Node.js stdlib â€” zero external dependencies.
 */

import { readdirSync, readFileSync, writeFileSync, rmSync, mkdirSync, existsSync } from 'fs'
import { join, basename, resolve, dirname } from 'path'
import { fileURLToPath } from 'url'

const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)
const ROOT = resolve(__dirname, '..')

const ICONS_INPUT = join(ROOT, 'node_modules', 'remixicon', 'icons')
const ICONS_OUTPUT = join(ROOT, 'packages', 'icons')
const GENERATED_DIR = join(ICONS_OUTPUT, 'generated')

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

/** Convert a kebab-case string to PascalCase */
function toPascalCase(str) {
  return str
    .split(/[-_\s]+/)
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join('')
}

/** Normalise a category folder name to a kebab-case slug */
function categorySlug(folderName) {
  return folderName
    .replace(/ & /g, '-and-')
    .toLowerCase()
    .replace(/\s+/g, '-')
}

/** Extract the first `d="..."` value from an SVG string */
function extractPathData(svgContent) {
  const match = svgContent.match(/d="([^"]+)"/)
  return match ? match[1] : null
}

// ---------------------------------------------------------------------------
// Main
// ---------------------------------------------------------------------------

function main() {
  // 1. Validate input exists
  if (!existsSync(ICONS_INPUT)) {
    console.error(
      `Error: remixicon not found at ${ICONS_INPUT}\n` +
      'Run "yarn add -D remixicon" first.'
    )
    process.exit(1)
  }

  // 2. Clean & recreate output
  rmSync(GENERATED_DIR, { recursive: true, force: true })
  mkdirSync(GENERATED_DIR, { recursive: true })

  // 3. Read all categories
  const categoryFolders = readdirSync(ICONS_INPUT, { withFileTypes: true })
    .filter(d => d.isDirectory())
    .map(d => d.name)
    .sort()

  const allComponents = []       // { componentName, fileName, pathData, category, baseName, variant }
  const categorySlugs = new Set()

  for (const folder of categoryFolders) {
    const slug = categorySlug(folder)
    categorySlugs.add(slug)

    const categoryDir = join(ICONS_INPUT, folder)
    const svgFiles = readdirSync(categoryDir)
      .filter(f => f.endsWith('.svg'))
      .sort()

    for (const svgFile of svgFiles) {
      const svgPath = join(categoryDir, svgFile)
      const svgContent = readFileSync(svgPath, 'utf-8')
      const pathData = extractPathData(svgContent)

      if (!pathData) {
        console.warn(`Warning: no path data found in ${svgFile}, skipping`)
        continue
      }

      const fileNameNoExt = basename(svgFile, '.svg') // e.g. "arrow-right-line"
      const componentName = 'Ri' + toPascalCase(fileNameNoExt) // e.g. "RiArrowRightLine"

      // Determine base name and variant
      let baseName = fileNameNoExt
      let variant = null
      if (fileNameNoExt.endsWith('-line')) {
        baseName = fileNameNoExt.slice(0, -5)
        variant = 'line'
      } else if (fileNameNoExt.endsWith('-fill')) {
        baseName = fileNameNoExt.slice(0, -5)
        variant = 'fill'
      }

      allComponents.push({
        componentName,
        fileName: fileNameNoExt,
        pathData,
        category: slug,
        baseName,
        variant,
      })
    }
  }

  // Sort all components alphabetically by component name
  allComponents.sort((a, b) => a.componentName.localeCompare(b.componentName))

  // 4. Write per-icon .tsx files
  for (const icon of allComponents) {
    const filePath = join(GENERATED_DIR, `${icon.componentName}.tsx`)
    const content =
      `import { createIcon } from '../createIcon'\n` +
      `export const ${icon.componentName} = createIcon('${icon.pathData}', '${icon.componentName}')\n`
    writeFileSync(filePath, content)
  }

  // 5. Write barrel export (packages/icons/index.ts)
  const indexLines = [
    '// This file is auto-generated by scripts/generate-icons.mjs',
    '// Do not edit manually.',
    '',
  ]
  for (const icon of allComponents) {
    indexLines.push(`export { ${icon.componentName} } from './generated/${icon.componentName}'`)
  }
  indexLines.push(`export type { IconFC } from './createIcon'`)
  indexLines.push('')
  writeFileSync(join(ICONS_OUTPUT, 'index.ts'), indexLines.join('\n'))

  // 6. Write types file (packages/icons/types.ts)
  const sortedFileNames = allComponents.map(c => c.fileName).sort()
  const sortedCategories = [...categorySlugs].sort()

  const typesLines = [
    '// This file is auto-generated by scripts/generate-icons.mjs',
    '// Do not edit manually.',
    '',
    "export type { IconFC } from './createIcon'",
    '',
    'export type IconName =',
  ]
  for (let i = 0; i < sortedFileNames.length; i++) {
    const prefix = i === 0 ? '  | ' : '  | '
    typesLines.push(`${prefix}'${sortedFileNames[i]}'`)
  }
  typesLines.push('')
  typesLines.push('export type IconCategory =')
  for (let i = 0; i < sortedCategories.length; i++) {
    typesLines.push(`  | '${sortedCategories[i]}'`)
  }
  typesLines.push('')
  writeFileSync(join(ICONS_OUTPUT, 'types.ts'), typesLines.join('\n'))

  // 7. Write manifest (packages/icons/manifest.json)
  // Group icons by base name
  const iconMap = new Map()
  for (const icon of allComponents) {
    if (!iconMap.has(icon.baseName)) {
      iconMap.set(icon.baseName, {
        name: icon.baseName,
        category: icon.category,
        variants: [],
        components: {},
      })
    }
    const entry = iconMap.get(icon.baseName)
    if (icon.variant) {
      entry.variants.push(icon.variant)
      entry.components[icon.variant] = icon.componentName
    } else {
      // Icons without -line/-fill suffix (standalone)
      entry.variants.push('default')
      entry.components['default'] = icon.componentName
    }
  }

  // Sort icon entries by name, sort variants within each
  const iconEntries = [...iconMap.values()]
    .sort((a, b) => a.name.localeCompare(b.name))
    .map(entry => ({
      ...entry,
      variants: entry.variants.sort(),
    }))

  // Get remixicon version from its package.json
  let remixVersion = 'unknown'
  try {
    const remixPkg = JSON.parse(
      readFileSync(join(ROOT, 'node_modules', 'remixicon', 'package.json'), 'utf-8')
    )
    remixVersion = remixPkg.version
  } catch {
    // version stays 'unknown'
  }

  const manifest = {
    version: remixVersion,
    count: allComponents.length,
    categories: sortedCategories,
    icons: iconEntries,
  }

  writeFileSync(
    join(ICONS_OUTPUT, 'manifest.json'),
    JSON.stringify(manifest, null, 2) + '\n'
  )

  // 8. Summary
  console.log(
    `Generated ${allComponents.length} icon components across ${sortedCategories.length} categories`
  )
}

main()
