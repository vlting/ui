<!-- auto-queue -->
# Commit History
- `73eb67c` refactor(Pagination): compose with Button component
- `2826dac` refactor(Pagination): compose with Button component (#004) [merge]

# Refactor Pagination to Compose with Button Component

## Context
The current `Pagination` component (`packages/components/Pagination/Pagination.tsx`) has its own custom-styled `PageButton`, `NavButton`, etc. using raw `styled(XStack, {...})` with duplicate hover/focus/press styles. It should instead **compose using the existing Button component** so that Pagination buttons inherit all Button variants, theming, and interaction states.

The Button component (`packages/components/Button/Button.tsx`) supports these variants: `default`, `solid`, `secondary`, `destructive`, `outline`, `ghost`, `link` — and sizes: `xs`, `sm`, `md`, `lg`, `icon`.

## Requirements

### New Props API
The `PaginationProps` interface should be extended to allow users to control which Button variant is used for each part:

```typescript
export interface PaginationProps {
  currentPage: number
  totalPages: number
  onPageChange: (page: number) => void
  siblingCount?: number
  size?: 'xs' | 'sm' | 'md' | 'lg'
  /** Button variant for Previous/Next buttons. Default: 'ghost' */
  navVariant?: ButtonVariant
  /** Button variant for numbered page buttons. Default: 'outline' */
  pageVariant?: ButtonVariant
  /** Button variant for the currently selected page button. Default: 'default' */
  activePageVariant?: ButtonVariant
}
```

### Implementation

1. **Import the Button component** from `../Button` (or wherever it resolves within the package).

2. **Replace `PageButton`/`NavButton` styled components** with actual `<Button>` usage:
   - Previous/Next buttons: `<Button variant={navVariant} size={size}>Previous</Button>`
   - Numbered page buttons: `<Button variant={pageVariant} size={size}>{page}</Button>`
   - Active page button: `<Button variant={activePageVariant} size={size}>{page}</Button>`

3. **Keep native `<button>` as the outer element.** The current pattern wraps Tamagui styled components inside native `<button>` elements for correct HTML semantics. The Button component itself should render as a `<button>` HTML tag. Verify the Button component renders the correct HTML tag (check if the `tag: 'button'` issue from MEMORY.md applies here). If Button doesn't render a native `<button>`, keep the current native `<button>` wrapper pattern.

4. **Remove the custom styled components** (`PageButton`, `PageButtonText`, `NavButton`, `NavButtonText`) — they become unnecessary.

5. **Keep the `EllipsisText`** styled component (or simplify to a plain Text) — the ellipsis is not a button.

6. **Keep the `computePageRange` utility** unchanged — it's pure logic and works correctly.

7. **Preserve all compound sub-components** (`Pagination.Root`, `.Previous`, `.Next`, `.Item`, `.Ellipsis`) and update them to use Button internally too.

8. **Preserve accessibility:** `role="navigation"`, `aria-label`, `aria-current="page"`, disabled states.

### Example Usage (what a consumer would write)
```tsx
<Pagination.Root
  currentPage={3}
  totalPages={10}
  onPageChange={setPage}
  navVariant="ghost"
  pageVariant="outline"
  activePageVariant="default"
/>
```

## Scope
- `packages/components/Pagination/Pagination.tsx`
- `packages/components/Pagination/index.ts` (if export changes needed)

## Acceptance Criteria
- Pagination buttons are composed from the Button component
- Users can set `navVariant`, `pageVariant`, and `activePageVariant` props
- Sensible defaults: ghost for nav, outline for pages, default for active page
- All buttons render as `<button>` HTML tags
- Hover and focus states match the Button component's behavior
- The `computePageRange` algorithm is unchanged
- All compound sub-components still work
- TypeScript compiles cleanly
